'use client';

import { onScreenShot } from '@/components/GridEditorV3/utils';
import ImageCropper from '@/components/ImageCropper';
import LibPicture from '@/components/LibPicture';
import { API, cdnApi, getAppId, getWorkData2, request, updateWorksDetail2 } from '@/services';
import APPBridge from '@/store/app-bridge';
import { getCookie } from '@/utils/cookie';
import { canUseRnChoosePic, showRnChoosePic } from '@/utils/rnChoosePic';
import { SerializedWorksEntity, trpc } from '@/utils/trpc';
import { Input } from '@workspace/ui/components/input';
import { Loading } from '@workspace/ui/components/loading';
import { ResponsiveDialog } from '@workspace/ui/components/responsive-dialog';
import { Textarea } from '@workspace/ui/components/textarea';
import dayjs from 'dayjs';
import zhCn from 'dayjs/locale/zh-cn';
import relativeTime from 'dayjs/plugin/relativeTime';
import { Pencil } from 'lucide-react';
import { useTranslations } from 'next-intl';
import { useEffect, useRef, useState } from 'react';
import toast from 'react-hot-toast';
import { useStore } from '../../store';
import { IWorksData } from '../GridEditorV3/works-store/types';

dayjs.extend(relativeTime);
dayjs.locale(zhCn);

interface WorkInfoCardProps {
  work: SerializedWorksEntity;
  purchaseStatus?: 'purchased' | 'not-purchased' | null;
  onClick?: () => void;
  loading?: boolean;
  onWorkUpdate?: (work: SerializedWorksEntity) => void;
}

export function WorkInfoCardEditable({
  work,
  onClick,
  loading = false,
  onWorkUpdate,
}: WorkInfoCardProps) {
  const t = useTranslations('WorkInfoCard');
  const tGrid = useTranslations('GridEditor');
  const resizeWidth = 192; // 96px * 2 for retina

  // ç¼–è¾‘ç›¸å…³çŠ¶æ€
  const [showEditDialog, setShowEditDialog] = useState(false);
  const [editTitle, setEditTitle] = useState(work.title || '');
  const [editDesc, setEditDesc] = useState((work as any).desc || '');
  const [editCover, setEditCover] = useState(work.cover || '');
  const [generatingContent, setGeneratingContent] = useState(false);
  const [showCrop, setShowCrop] = useState(false);
  const [cropImageUrl, setCropImageUrl] = useState('');
  const [showPictureSelector, setShowPictureSelector] = useState(false);
  const inputRef = useRef<HTMLInputElement | null>(null);
  const hasAutoGeneratedRef = useRef(false); // æ ‡è®°æ˜¯å¦å·²ç»è‡ªåŠ¨ç”Ÿæˆè¿‡
  const store = useStore();

  // åŒæ­¥å¤–éƒ¨ work æ•°æ®åˆ°ç¼–è¾‘çŠ¶æ€
  useEffect(() => {
    setEditTitle(work.title || '');
    setEditDesc(work.desc || '');
    setEditCover(work.cover || '');
  }, [work]);

  // åˆå§‹åŒ–æ—¶è‡ªåŠ¨ç”Ÿæˆæ ‡é¢˜å’Œæè¿°ï¼ˆå¦‚æœ is_title_desc_modified === falseï¼‰
  useEffect(() => {
    const autoGenerate = async () => {
      if (!work.id || hasAutoGeneratedRef.current) return;

      // æ ‡è®°å·²æ‰§è¡Œï¼Œé¿å…é‡å¤ç”Ÿæˆ
      hasAutoGeneratedRef.current = true;

      try {
        // è·å–ä½œå“æ•°æ®
        const res = await getWorkData2(work.id);
        const detail = res?.detail;
        const worksData = res?.work_data;

        if (!detail) return;

        // å‡†å¤‡å¼‚æ­¥ä»»åŠ¡
        const tasks: Array<Promise<any>> = [];
        let needGeneration = false;

        // æ£€æŸ¥æ˜¯å¦éœ€è¦ç”Ÿæˆå°é¢ï¼ˆç‹¬ç«‹äºæ ‡é¢˜æè¿°çš„çŠ¶æ€ï¼‰
        if (!detail.cover || /gif/gi.test(detail.cover)) {
          console.log('[WorkInfoCard] éœ€è¦ç”Ÿæˆå°é¢');
          needGeneration = true;
          tasks.push(generateScreenshot());
        }

        // åˆ¤æ–­æ˜¯å¦éœ€è¦è‡ªåŠ¨ç”Ÿæˆæ ‡é¢˜å’Œæè¿°ï¼ˆéœ€è¦ worksData ä¸” is_title_desc_modified === falseï¼‰
        if (worksData && !detail.is_title_desc_modified) {
          console.log('[WorkInfoCard] éœ€è¦ç”Ÿæˆæ ‡é¢˜å’Œæè¿°');
          needGeneration = true;
          tasks.push(generateMeta(worksData));
        }

        // å¦‚æœæœ‰éœ€è¦ç”Ÿæˆçš„å†…å®¹ï¼Œæ˜¾ç¤º loading å¹¶ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
        if (needGeneration && tasks.length) {
          setGeneratingContent(true);
          try {
            const results = await Promise.all(tasks);

            // å¤„ç†å°é¢ç”Ÿæˆç»“æœï¼ˆå…ˆå¤„ç†ï¼Œå› ä¸ºå¯èƒ½æ²¡æœ‰æ ‡é¢˜æè¿°ç”Ÿæˆï¼‰
            const screenshotResult = results.find(
              r => r && r.success && r.cover
            );
            if (screenshotResult && screenshotResult.cover) {
              setEditCover(screenshotResult.cover);
              if (onWorkUpdate) {
                const updatedWork = { ...work };
                updatedWork.cover = screenshotResult.cover;
                onWorkUpdate(updatedWork);
              }
            }

            // å¤„ç†æ ‡é¢˜æè¿°ç”Ÿæˆç»“æœ
            const metaResult = results.find(r => r && r.title);
            if (metaResult && metaResult.title) {
              setEditTitle(metaResult.title);
              setEditDesc(metaResult.desc || '');
              console.log('[WorkInfoCard] ä½¿ç”¨ç”Ÿæˆçš„æ ‡é¢˜:', metaResult.title);

              // é€šçŸ¥å¤–éƒ¨æ›´æ–°
              if (onWorkUpdate) {
                const updatedWork = { ...work };
                updatedWork.title = metaResult.title;
                updatedWork.desc = metaResult.desc || '';
                updatedWork.is_title_desc_modified = true;
                onWorkUpdate(updatedWork);
              }
            }
          } catch (error) {
            console.error('[WorkInfoCard] ç”Ÿæˆå†…å®¹æ—¶å‡ºé”™:', error);
          } finally {
            setGeneratingContent(false);
          }
        }
      } catch (error) {
        console.error('[WorkInfoCard] è‡ªåŠ¨ç”Ÿæˆå¤±è´¥:', error);
        setGeneratingContent(false);
      }
    };

    // åªåœ¨ç»„ä»¶é¦–æ¬¡åŠ è½½æ—¶æ‰§è¡Œä¸€æ¬¡
    autoGenerate();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [work.id]);

  const handleClick = () => {
    if (!loading && onClick) {
      onClick();
    }
  };

  const handleEditClick = (e: React.MouseEvent) => {
    e.stopPropagation();
    setShowEditDialog(true);
  };

  // ç”Ÿæˆæˆªå›¾çš„é€šç”¨å‡½æ•°
  const generateScreenshot = async () => {
    try {
      const screenshotRes = await onScreenShot({
        id: work.id,
        width: 375,
        height: 375,
        appid: getAppId(),
      });
      const coverUrl = cdnApi(screenshotRes[0], {
        resizeWidth: 375,
        resizeHeight: 375,
      });
      setEditCover(coverUrl);
      await updateWorksDetail2(work.id, {
        cover: coverUrl,
      } as any);
      console.log('[WorkInfoCard] æˆªå›¾ç”ŸæˆæˆåŠŸ:', coverUrl);
      return { success: true, cover: coverUrl };
    } catch (error) {
      console.error('[WorkInfoCard] ç”Ÿæˆæˆªå›¾å¤±è´¥:', error);
      return { success: false };
    }
  };

  // ç”Ÿæˆæ ‡é¢˜å’Œæè¿°çš„é€šç”¨å‡½æ•°
  const generateMeta = async (worksData: IWorksData) => {
    try {
      const layers = worksData.layersMap;
      let workText = '';

      Object.values(layers).forEach(layer => {
        if (layer.elementRef === 'Text' && layer.attrs?.text) {
          workText += layer.attrs.text + ' ';
        }
      });

      workText = workText.trim();

      if (!workText) {
        console.log('[WorkInfoCard] æœªæ‰¾åˆ°æ–‡æœ¬å†…å®¹ï¼Œä½¿ç”¨é»˜è®¤æ ‡é¢˜');
        return {
          success: false,
          title: t('æˆ‘çš„ä½œå“'),
          desc: t('æ¬¢è¿æŸ¥çœ‹'),
        };
      }

      console.log('[WorkInfoCard] æå–çš„æ–‡æœ¬é•¿åº¦:', workText.length);

      const useV11API = typeof process !== 'undefined' && process.env.APIV11 === 'true';

      let metaRes: { title?: string; desc?: string } | undefined;

      if (useV11API) {
        // ä½¿ç”¨ tRPC è°ƒç”¨ç«å±±å¼•æ“ ARK APIï¼ŒæŒ‰å½“å‰è¯­è¨€ç”Ÿæˆæ ‡é¢˜æè¿°
        const currentLocale = getCookie('NEXT_LOCALE') || 'zh-CN';
        metaRes = await trpc.aiGenerate.generateWorkMeta.mutate({
          workText: workText.slice(0, 500),
          language: currentLocale,
        });
      } else {
        metaRes = await request.post(
          `${API('apiv10')}/ai-generate/work-meta`,
          {
            workText: workText.slice(0, 500),
          }
        );
      }

      if (metaRes && metaRes.title && metaRes.desc) {
        console.log('[WorkInfoCard] AIç”Ÿæˆç»“æœ:', {
          title: metaRes.title,
          desc: metaRes.desc,
        });

        // ä¿å­˜ç”Ÿæˆçš„æ ‡é¢˜å’Œæè¿°
        await updateWorksDetail2(work.id, {
          title: metaRes.title,
          desc: metaRes.desc,
          is_title_desc_modified: true,
        });

        setEditTitle(metaRes.title);
        setEditDesc(metaRes.desc);

        console.log(
          '[WorkInfoCard] æ ‡é¢˜æè¿°å·²ä¿å­˜ï¼Œis_title_desc_modified è®¾ç½®ä¸º true'
        );

        return {
          success: true,
          title: metaRes.title,
          desc: metaRes.desc,
        };
      } else {
        console.warn('[WorkInfoCard] AI è¿”å›ç»“æœæ ¼å¼ä¸æ­£ç¡®:', metaRes);
        return {
          success: false,
          title: t('æˆ‘çš„ä½œå“'),
          desc: workText.slice(0, 60),
        };
      }
    } catch (error) {
      console.error('[WorkInfoCard] ç”Ÿæˆæ ‡é¢˜æè¿°å¤±è´¥:', error);
      return {
        success: false,
        title: t('æˆ‘çš„ä½œå“'),
        desc: t('æ¬¢è¿æŸ¥çœ‹'),
      };
    }
  };

  // ç‚¹å‡»"é‡æ–°ç”Ÿæˆ"æŒ‰é’®å¼ºåˆ¶é‡æ–°ç”Ÿæˆ
  const regenerateContent = async () => {
    if (!work.id) {
      toast.error(t('ç¼ºå°‘ä½œå“ID'));
      return;
    }

    setGeneratingContent(true);

    try {
      const res = await getWorkData2(work.id);
      const worksData = res?.work_data;

      if (!worksData) {
        toast.error(t('æœªæ‰¾åˆ°ä½œå“æ•°æ®'));
        return;
      }

      // å¹¶è¡Œç”Ÿæˆæˆªå›¾å’Œæ ‡é¢˜æè¿°
      const [screenshotResult, metaResult] = await Promise.all([
        generateScreenshot(),
        generateMeta(worksData),
      ]);

      // æ›´æ–°ç•Œé¢æ ‡é¢˜å’Œæè¿°
      if (metaResult && metaResult.title) {
        setEditTitle(metaResult.title);
        setEditDesc(metaResult.desc || '');
      }

      if (screenshotResult?.success || metaResult?.success) {
        toast.success(t('ç”Ÿæˆå®Œæˆ'));
        // é€šçŸ¥å¤–éƒ¨æ›´æ–°
        if (onWorkUpdate) {
          const updatedWork = { ...work };
          if (screenshotResult?.cover) {
            updatedWork.cover = screenshotResult.cover;
          }
          if (metaResult?.title) {
            updatedWork.title = metaResult.title;
            (updatedWork as any).desc = metaResult.desc || '';
          }
          onWorkUpdate(updatedWork);
        }
      } else {
        toast.error(t('ç”Ÿæˆå¤±è´¥ï¼Œè¯·é‡è¯•'));
      }
    } catch (error) {
      console.error('[WorkInfoCard] é‡æ–°ç”Ÿæˆå†…å®¹å¤±è´¥:', error);
      toast.error(t('ç”Ÿæˆå¤±è´¥ï¼Œè¯·é‡è¯•'));
    } finally {
      setGeneratingContent(false);
    }
  };

  // æ›´æ–°æ ‡é¢˜
  const updateTitle = async (title: string) => {
    try {
      await updateWorksDetail2(work.id, {
        title,
        is_title_desc_modified: true,
      } as any);
      if (onWorkUpdate) {
        const updatedWork = { ...work, title };
        onWorkUpdate(updatedWork);
      }
    } catch (error) {
      console.error('æ›´æ–°æ ‡é¢˜å¤±è´¥:', error);
      toast.error(t('æ›´æ–°æ ‡é¢˜å¤±è´¥'));
    }
  };

  // æ›´æ–°æè¿°
  const updateDesc = async (desc: string) => {
    try {
      await updateWorksDetail2(work.id, {
        desc,
        is_title_desc_modified: true,
      } as any);
      if (onWorkUpdate) {
        const updatedWork = { ...work };
        (updatedWork as any).desc = desc;
        onWorkUpdate(updatedWork);
      }
    } catch (error) {
      console.error('æ›´æ–°æè¿°å¤±è´¥:', error);
      toast.error(t('æ›´æ–°æè¿°å¤±è´¥'));
    }
  };

  // å¤„ç†å°é¢ä¸Šä¼ 
  const onChangeUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const maxSize = 50;
    let files = e.target.files;
    if (files?.length) {
      const file = files[0];
      if ((file as File).size * 0.001 > maxSize * 1024) {
        toast.error(t('æ–‡ä»¶ä¸èƒ½è¶…è¿‡{size}mb', { size: maxSize }));
        return;
      }
      setCropImageUrl(URL.createObjectURL(file));
      setShowCrop(true);
    }
  };

  // å¤„ç†å°é¢è£å‰ªå®Œæˆ
  const handleCoverChange = async (url: string) => {
    setEditCover(url);
    await updateWorksDetail2(work.id, {
      cover: url,
    } as any);
    if (onWorkUpdate) {
      const updatedWork = { ...work, cover: url };
      onWorkUpdate(updatedWork);
    }
    setShowCrop(false);
  };

  return (
    <>
      <div
        onClick={handleClick}
        className={`relative ${onClick && !loading
          ? 'cursor-pointer'
          : loading
            ? 'cursor-wait opacity-60'
            : ''
          }`}
      >
        <div className='flex gap-2 items-start'>
          {/* ç¼©ç•¥å›¾ */}
          <div className='w-[72px] h-[72px] relative flex-shrink-0 overflow-hidden rounded-[14px] bg-slate-100 border border-slate-100 shadow-sm'>
            {work.cover ? (
              // eslint-disable-next-line @next/next/no-img-element
              <img
                src={cdnApi(work.cover, { resizeWidth })}
                alt={work.title}
                className='w-full h-full object-cover'
              />
            ) : (
              <div className='w-full h-full flex flex-col items-center justify-center text-gray-400'>
                <div className='text-[24px] mb-1'>ğŸ–¼ï¸</div>
              </div>
            )}
            {/* åŠ è½½è’™å±‚ */}
            {loading && (
              <div className='absolute inset-0 bg-black bg-opacity-30 flex items-center justify-center'>
                <div className='w-6 h-6 border-2 border-white border-t-transparent rounded-full animate-spin' />
              </div>
            )}
          </div>

          {/* å†…å®¹ */}
          <div className='flex-1 min-w-0 pt-0.5 relative'>
            <div className='flex items-start justify-between mb-1'>
              <h3 className='text-base font-semibold leading-6 text-[#0f172b] pr-8'>
                {work.title}
              </h3>
              {/* ç¼–è¾‘æŒ‰é’® */}
              <button
                className='absolute top-0 right-0 w-[30px] h-[30px] flex items-center justify-center rounded-full hover:bg-slate-100 transition-colors'
                onClick={e => {
                  e.stopPropagation();
                  setShowEditDialog(true);
                }}
              >
                <Pencil className='w-[18px] h-[18px] text-[#64748b]' />
              </button>
            </div>
            {/* æè¿° */}
            {(work as any).desc && (
              <p className='text-sm leading-5 text-[#62748e] line-clamp-1 mb-1'>
                {(work as any).desc}
              </p>
            )}
          </div>
        </div>
      </div>

      {/* ç¼–è¾‘å¼¹çª— */}
      <ResponsiveDialog
        isOpen={showEditDialog}
        onOpenChange={setShowEditDialog}
        handleOnly={true}
        title={t('ç¼–è¾‘æ ‡é¢˜ã€æè¿°å’Œå°é¢')}
        isDialog
      >
        <div className='p-4 space-y-3'>
          <div className='flex items-center justify-between'>
            <p className='text-xs font-semibold text-[#64748B] leading-[18px]'>
              {t('ç¼–è¾‘æ ‡é¢˜ã€æè¿°å’Œå°é¢')}
            </p>
            <div
              className='px-2 py-0.5 rounded cursor-pointer hover:bg-[#EEF2FF] transition-colors'
              onClick={regenerateContent}
            >
              <p className='text-xs font-semibold text-[#3358D4] leading-[18px]'>
                {t('é‡æ–°ç”Ÿæˆ')}
              </p>
            </div>
          </div>

          {/* æ ‡é¢˜è¾“å…¥ */}
          <div className='relative'>
            <Input
              value={editTitle}
              onChange={e => setEditTitle(e.target.value)}
              onBlur={() => updateTitle(editTitle)}
              className='w-full bg-white border-[#C1D0FF] rounded-md px-3 py-2 text-sm font-semibold text-[rgba(0,0,0,0.88)] leading-5 pr-14'
              placeholder={t('è¯·è¾“å…¥æ ‡é¢˜')}
              maxLength={36}
            />
            <div className='absolute right-3 top-1/2 -translate-y-1/2 text-xs text-[#020617] leading-[18px]'>
              {editTitle.length}/36
            </div>
          </div>

          {/* å°é¢å’Œæè¿° */}
          <div className='flex gap-2'>
            {/* å°é¢ */}
            <div className='relative flex-shrink-0'>
              <input
                className='hidden'
                ref={inputRef}
                onChange={onChangeUpload}
                type='file'
                accept='image/*'
                multiple={false}
                title='å°é¢ä¸Šä¼ '
              />
              <div className='w-24 h-24 rounded-md bg-gray-200 overflow-hidden'>
                {editCover ? (
                  <img
                    src={cdnApi(editCover)}
                    alt='å°é¢'
                    className='w-full h-full object-cover'
                  />
                ) : (
                  <div className='w-full h-full flex items-center justify-center text-xs text-gray-400'>
                    {t('å°é¢')}
                  </div>
                )}
              </div>
              <div
                className='absolute bottom-0 left-0 right-0 bg-black/60 text-white text-xs text-center py-1 rounded-b-md cursor-pointer'
                onClick={async () => {
                  if (await canUseRnChoosePic()) {
                    showRnChoosePic((url?: string) => {
                      if (url) {
                        setCropImageUrl(url);
                        setShowCrop(true);
                      }
                    }, tGrid);
                  } else if (APPBridge.judgeIsInApp()) {
                    setShowPictureSelector(true);
                  } else {
                    inputRef.current?.click();
                  }
                }}
              >
                {t('æ›´æ¢å°é¢')}
              </div>
            </div>

            {/* æè¿° */}
            <div className='flex-1 relative'>
              <Textarea
                value={editDesc}
                onChange={e => setEditDesc(e.target.value)}
                onBlur={() => updateDesc(editDesc)}
                className='w-full bg-white border-[#C1D0FF] rounded-md px-3 py-2 text-xs text-[rgba(0,0,0,0.88)] leading-[18px] min-h-[96px] resize-none'
                placeholder={t('è¯·è¾“å…¥æè¿°')}
                maxLength={60}
              />
              <div className='absolute bottom-2 right-3 text-xs text-[#020617] leading-[18px]'>
                {editDesc.length}/60
              </div>
            </div>
          </div>
        </div>
      </ResponsiveDialog>

      {/* å°é¢è£å‰ªå¼¹çª— */}
      <ResponsiveDialog
        isOpen={showCrop}
        onOpenChange={setShowCrop}
        handleOnly={true}
      >
        <ImageCropper
          worksId={work.id}
          imageUrl={cropImageUrl}
          onClose={() => setShowCrop(false)}
          onChange={handleCoverChange}
        />
      </ResponsiveDialog>

      {/* å›¾ç‰‡é€‰æ‹©å¼¹çª— */}
      <ResponsiveDialog
        isOpen={showPictureSelector}
        onOpenChange={setShowPictureSelector}
        title={t('æ›´æ¢å°é¢')}
        contentProps={{
          className: 'pt-2',
        }}
      >
        <LibPicture
          preUpload={false}
          onSelectItem={(url: string) => {
            setCropImageUrl(url);
            setShowCrop(true);
            setShowPictureSelector(false);
          }}
        />
      </ResponsiveDialog>

      {/* ç”Ÿæˆä¸­æç¤ºå¼¹çª— */}
      <ResponsiveDialog
        isOpen={generatingContent}
        isDialog
        contentProps={{
          className: 'max-w-[320px]',
        }}
      >
        <div className='p-4 flex flex-col items-center gap-2 mx-2 max-w-[320px]'>
          <Loading />
          <div className=''>{t('è¯·ç¨ç­‰ï¼Œæ ‡é¢˜å’Œå°é¢è‡ªåŠ¨ç”Ÿæˆä¸­')}</div>
        </div>
      </ResponsiveDialog>
    </>
  );
}
